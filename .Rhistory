paste( paste0(1,2), paste0(3,4), sep = ";")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
install.packages("shinyFiles")
library(shinyFiles)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
devtools::install_github('wleepang/shiny-directory-input')
#devtools::install_github('wleepang/shiny-directory-input')
library(shinyDirectoryInput)
runApp()
shinyDirectoryInput::runDirinputExample()
choose.dir()
choose.dir()
kk <- choose.dir()
kk
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
filepath
filepath$datapath
runApp()
runApp()
imagenNew$clf
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
imagenNew$bigAreas
imagenNew$properties
imagenNew$stat
imagenNew$minArea
imagenNew$maxArea
imagenNew$media
imagenNew$percarea
imagenNew$ratio
imagenNew$areas
runApp()
#validate(need(input$thres,""))
validate(need(isTRUE(stat$ok),"" ) )
runApp()
##OJO antes de ejecutar esto hay que activar el entorno virtual
## source ~/env/Rython/bin/activate
library(reticulate)
library(tidyverse)
library(EBImage)
reticulate::use_virtualenv("~/Rython/")
source_python("functions.py", convert = TRUE)
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/mini.jpg"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
#Imagen from python
cargarImagen(imagenNew, imagenNew$image)
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
display(imgR, method = "raster")
# definir puntos de entrenamiento
va <- locator(n = imagenNew$NUM, type = "p")
nova <- locator(n = imagenNew$NUM, type = "p")
vac <- featureCoord(va)
novac <- featureCoord(nova)
vac <- unname(vac)
vac <- r_to_py(vac, convert = FALSE)
novac <- unname(novac)
novac <- r_to_py(novac)
## asignar puntos a objeto
imagenNew$set_xy(vac, novac)
#generar vector de caracteristicas
fvp = computeFeatureVector(imagenNew)
#crear clasificador
clf = trainKnn(imagenNew)
#Clasificar imagen
B = classImage(imagenNew)
imagenNew$B = B
#visualizar la clasificacion
BR <- py_2_R_imageBW(B)
display(BR, method = "raster")
#Crear etiquetas/watersheed/medirAreas
statistics(imagenNew)
#Thresholding
thr = 2000 # se pasará por según valor deslizador
threshold(imagenNew, thr)
imagenNew$ratio
imagenNew$bigAreas
imagenNew$bigMean
imagenNew$bigPercent
imagenNew$bigRange
imagenNew$ratio
imagenNew$bigAreas
imagenNew$areas
imagenNew$bigAreas
imagenNew$areas[0]
imagenNew$areas[2]
imagenNew$areas[1]
source_python("functions.py", convert = TRUE)
threshold(imagenNew, thr)
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/mini.jpg"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
#Imagen from python
cargarImagen(imagenNew, imagenNew$image)
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
display(imgR, method = "raster")
# definir puntos de entrenamiento
va <- locator(n = imagenNew$NUM, type = "p")
nova <- locator(n = imagenNew$NUM, type = "p")
library(xaringan)
vac <- featureCoord(va)
novac <- featureCoord(nova)
vac <- unname(vac)
vac <- r_to_py(vac, convert = FALSE)
novac <- unname(novac)
novac <- r_to_py(novac)
## asignar puntos a objeto
imagenNew$set_xy(vac, novac)
#generar vector de caracteristicas
fvp = computeFeatureVector(imagenNew)
#crear clasificador
clf = trainKnn(imagenNew)
#Clasificar imagen
B = classImage(imagenNew)
imagenNew$B = B
#visualizar la clasificacion
BR <- py_2_R_imageBW(B)
display(BR, method = "raster")
#Crear etiquetas/watersheed/medirAreas
statistics(imagenNew)
#Thresholding
thr = 2000 # se pasará por según valor deslizador
threshold(imagenNew, thr)
imagenNew$ratio
imagenNew$bigAreaSum
10000/100
100/10000
10000*0.5
100*0.5
50/5000
100/9
100*0.5
9*0.5
50/4.5
runApp()
runApp()
runApp()
runApp()
runApp()
imagenNew$bigRange
2134*0.2^2
imagenNew$bigRange[[1]]
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
uploadImage$ok
uploadImage$ok
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
##OJO antes de ejecutar esto hay que activar el entorno virtual
## source ~/env/Rython/bin/activate
Sys.setenv(RETICULATE_PYTHON="/home/fpsanz/Rython/bin/python3")
library(reticulate)
library(tidyverse)
library(EBImage)
source_python("functions.py", convert = TRUE)
search()
grepl("package:reticulate" ,search())
any(grepl("package:reticulate" ,search()))
if( any(grepl("package:reticulate" ,search()))){detach("package:reticulate")}
shiny::runApp()
runApp()
source_python("functions.py", convert = TRUE)
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/mini.jpg"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
#Imagen from python
cargarImagen(imagenNew, imagenNew$image)
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
display(imgR, method = "raster")
# definir puntos de entrenamiento
va <- locator(n = imagenNew$NUM, type = "p")
nova <- locator(n = imagenNew$NUM, type = "p")
vac <- featureCoord(va)
novac <- featureCoord(nova)
vac <- unname(vac)
vac <- r_to_py(vac, convert = FALSE)
novac <- unname(novac)
novac <- r_to_py(novac)
## asignar puntos a objeto
imagenNew$set_xy(vac, novac)
#generar vector de caracteristicas
fvp = computeFeatureVector(imagenNew)
fvp2 = py_eval("fvp = imagen.fvp")
fvp2 = py_eval(fvp = imagen.fvp)
fvp2 = py_eval(imagen.fvp)
imagen = py_eval(imagen=imagenNew)
imagen = py_eval("imagen=imagenNew")
#crear clasificador
clf = trainKnn(imagenNew)
clf = trainSVM(imagenNew)
source("utils.R")
#reticulate::use_python("/home/fpsanz/Rython/bin/python3", required = FALSE)
#reticulate::use_virtualenv("/home/fpsanz/Rython")
source_python("functions.py", convert = TRUE)
clf = trainSVM(imagenNew)
source_python("functions.py", convert = TRUE)
clf = trainSVM(imagenNew)
source_python("functions.py", convert = TRUE)
clf = trainSVM(imagenNew)
imagenNew$NUM
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
counter
counter =1
runApp()
shiny::runApp()
va$x
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/01_X100.tif"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
##OJO antes de ejecutar esto hay que activar el entorno virtual
## source ~/env/Rython/bin/activate
if( any(grepl("package:reticulate" ,search()))){detach("package:reticulate")}
Sys.setenv(RETICULATE_PYTHON="/home/fpsanz/Rython/bin/python3")
library(reticulate)
library(tidyverse)
library(EBImage)
#reticulate::use_virtualenv("~/.virtualenvs/Rython/")
#use_python("/usr/bin/python3")
source_python("functions.py", convert = TRUE)
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/01_X100.tif"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
shiny::runApp()
0.454/2
/2
0.454/2/2
runApp()
input$pixelsize
as.numeric(input$pixelsize)
runApp()
runApp()
runApp()
##OJO antes de ejecutar esto hay que activar el entorno virtual
## source ~/env/Rython/bin/activate
if( any(grepl("package:reticulate" ,search()))){detach("package:reticulate")}
Sys.setenv(RETICULATE_PYTHON="/home/fpsanz/Rython/bin/python3")
library(reticulate)
library(tidyverse)
library(EBImage)
#reticulate::use_virtualenv("~/.virtualenvs/Rython/")
#use_python("/usr/bin/python3")
source_python("functions.py", convert = TRUE)
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/01_X100.tif"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
#Imagen from python
cargarImagen(imagenNew, imagenNew$image)
imagenNew$image <- "./images/01_X100_05.jpg"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
#Imagen from python
cargarImagen(imagenNew, imagenNew$image)
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
#reticulate::use_virtualenv("~/.virtualenvs/Rython/")
#use_python("/usr/bin/python3")
source_python("functions.py", convert = TRUE)
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
source("utils.R")
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
display(imgR, method = "raster")
# definir puntos de entrenamiento
va <- locator(n = imagenNew$NUM, type = "p")
nova <- locator(n = imagenNew$NUM, type = "p")
vac <- featureCoord(va)
novac <- featureCoord(nova)
vac <- unname(vac)
vac <- r_to_py(vac, convert = FALSE)
novac <- unname(novac)
novac <- r_to_py(novac)
## asignar puntos a objeto
imagenNew$set_xy(vac, novac)
#generar vector de caracteristicas
fvp = computeFeatureVector(imagenNew)
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
source("utils.R")
runApp()
runApp()
#reticulate::use_python("/home/fpsanz/Rython/bin/python3", required = FALSE)
#reticulate::use_virtualenv("/home/fpsanz/Rython")
source_python("functions.py", convert = TRUE)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
##OJO antes de ejecutar esto hay que activar el entorno virtual
## source ~/env/Rython/bin/activate
if( any(grepl("package:reticulate" ,search()))){detach("package:reticulate")}
Sys.setenv(RETICULATE_PYTHON="/home/fpsanz/Rython/bin/python3")
library(reticulate)
library(tidyverse)
library(EBImage)
#reticulate::use_virtualenv("~/.virtualenvs/Rython/")
#use_python("/usr/bin/python3")
source_python("functions.py", convert = TRUE)
source("utils.R")
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/01_X100_05.jpg"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
#Imagen from python
cargarImagen(imagenNew, imagenNew$image)
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
display(imgR, method = "raster")
#load model
imagenNew$clf = loadModel(filepath$datapath)
#load model
imagenNew$clf = loadModel("/datos/repos/visionGUI/knnModel")
imagenNew$clf
B = classModel(imagenNew, imagenNew$clf)
#reticulate::use_virtualenv("~/.virtualenvs/Rython/")
#use_python("/usr/bin/python3")
source_python("functions.py", convert = TRUE)
source("utils.R")
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/01_X100_05.jpg"
imagenNew$set_NUM(10)
#load model
imagenNew$clf = loadModel("/datos/repos/visionGUI/knnModel")
B = classModel(imagenNew, imagenNew$clf)
B = classModel(imagenNew)
im = np.dstack((imagen.imageRGB, imagen.imageCIE))
imagen = imagenNew
im = np.dstack((imagen.imageRGB, imagen.imageCIE))
#load model
imagenNew$clf = loadModel("/datos/repos/visionGUI/knnModel")
imagen = imagenNew
imagen.imageRGB
#Clasificar imagen
B = classImage(imagenNew)
##OJO antes de ejecutar esto hay que activar el entorno virtual
## source ~/env/Rython/bin/activate
if( any(grepl("package:reticulate" ,search()))){detach("package:reticulate")}
Sys.setenv(RETICULATE_PYTHON="/home/fpsanz/Rython/bin/python3")
library(reticulate)
library(tidyverse)
library(EBImage)
#reticulate::use_virtualenv("~/.virtualenvs/Rython/")
#use_python("/usr/bin/python3")
source_python("functions.py", convert = TRUE)
source("utils.R")
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/01_X100_05.jpg"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
#Imagen from python
cargarImagen(imagenNew, imagenNew$image)
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
display(imgR, method = "raster")
#load model
imagenNew$clf = loadModel("/datos/repos/visionGUI/knnModel")
imagen = imagenNew
imagen.imageRGB
imagen.imagenRGB
imagen.clf
im = np.dstack( (imagen.imageRGB, imagen.imageCIE) )
im = np.reshape(im, ((imagen.imageRGB.shape[0] * imagen.imageRGB.shape[1]), 6))
im = np.dstack( (imagen.imageRGB, imagen.imageCIE) )
runApp()
#Crear instancia clase imagen
imagenNew <- Imagen(NULL)
imagenNew$image <- "./images/01_X100.jpg"
imagenNew$set_NUM(10)
#leer imagen en R directamente
imagenR <- readImage(imagenNew$image )
EBImage::display(imagenR, method = "raster")
EBImage::display(imagenR, method = "raster")
#Imagen from python
cargarImagen(imagenNew, imagenNew$image)
imgR <- py_2_R_imageColor(imagenNew$imageRGB)
display(imgR, method = "raster")
display(imgR, method = "raster")
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
